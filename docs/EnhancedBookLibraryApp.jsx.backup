// src/components/EnhancedBookLibraryApp.jsx - SUPER SAFE Manual Cover Updates
import React, { useState, useRef, useMemo } from 'react';
import {
  // Core components
  MD3Button,
  MD3Card,
  MD3TextField,
  MD3Checkbox,
  MD3Chip,
  MD3ChipGroup,
  MD3Switch,
  MD3Dialog,
  MD3DialogActions,
  MD3ProgressSnackbar,
  useSnackbar,
  
  // New components
  MD3FloatingActionButton,
  MD3BookLibraryFab,
  MD3Menu,
  MD3MenuItem,
  MD3MenuDivider,
  MD3BookActionsMenu,
  MD3SortMenu,
  MD3NavigationLayout,
  useResponsiveNavigation,
  
  // Hooks and providers
  useMaterial3Theme,
  useThemeColors,
  Material3ThemeProvider,
  MD3SnackbarProvider
} from './Material3';

// SAFE: Import service directly (no hooks)
import bookCoverService from '../services/BookCoverService';

// Import CSS
import './EnhancedBookLibraryApp.css';

// SUPER SAFE Enhanced Book Card with Manual Cover Updates Only
const EnhancedBookCard = ({ 
  book, 
  onRead, 
  onEdit, 
  onDelete, 
  onShare, 
  onAddToCollection, 
  onBookUpdate
}) => {
  const [menuOpen, setMenuOpen] = useState(false);
  const [menuAnchor, setMenuAnchor] = useState(null);
  const [findingCover, setFindingCover] = useState(false); // Simple loading state
  const cardRef = useRef();
  const { showSnackbar } = useSnackbar();

  // Your existing working cover logic (unchanged)
  const existingCoverUrl = book.cover || book.cover_url || null;
  const fallbackCoverUrl = `https://placehold.co/160x240/6750a4/ffffff?text=${encodeURIComponent(book.title?.slice(0,8) || 'Book')}`;
  const coverUrl = existingCoverUrl || fallbackCoverUrl;

  // Your existing event handlers (unchanged)
  const handleContextMenu = (e) => {
    e.preventDefault();
    setMenuAnchor({ x: e.clientX, y: e.clientY });
    setMenuOpen(true);
  };

  const handleMenuClick = (e) => {
    e.stopPropagation();
    const rect = e.currentTarget.getBoundingClientRect();
    setMenuAnchor({ x: rect.right, y: rect.top });
    setMenuOpen(true);
  };

  const handleCardClick = () => {
    onRead?.(book);
  };

  // NEW: SAFE manual cover finding (no hooks, no automatic calls)
  const handleFindCover = async (e) => {
    e.stopPropagation(); // Don't trigger card click
    
    if (!book.title || !book.author) {
      showSnackbar({
        message: 'Need book title and author to find cover',
        variant: 'error'
      });
      return;
    }

    setFindingCover(true);
    
    try {
      showSnackbar({
        message: `Looking for cover for "${book.title}"...`,
        variant: 'info'
      });

      // SAFE: Direct service call, no hooks
      const coverData = await bookCoverService.getBookData(
        book.title, 
        book.author, 
        book.isbn
      );

      if (coverData && coverData.cover && coverData.source !== 'placeholder') {
        // Found a real cover!
        showSnackbar({
          message: `âœ… Found cover from ${coverData.source}!`,
          variant: 'success'
        });

        // Call your existing update callback
        onBookUpdate?.('updateCover', {
          ...book,
          cover_url: coverData.cover,
          cover_small_url: coverData.coverSmall,
          cover_medium_url: coverData.coverMedium,
          cover_large_url: coverData.coverLarge,
          api_source: coverData.source,
          enhanced_metadata: {
            description: coverData.description,
            categories: coverData.categories,
            published_date: coverData.publishedDate,
            page_count: coverData.pageCount
          }
        });
      } else {
        // No cover found
        showSnackbar({
          message: `No cover found for "${book.title}"`,
          variant: 'info'
        });
      }
    } catch (error) {
      console.error('Cover search error:', error);
      showSnackbar({
        message: `Failed to find cover: ${error.message}`,
        variant: 'error'
      });
    } finally {
      setFindingCover(false);
    }
  };

  // Check if this book needs a cover
  const needsCover = !existingCoverUrl;

  console.log('ðŸ“š EnhancedBookCard Debug:', {
    title: book.title,
    isReading: book.isReading,
    hasOnBookUpdate: !!onBookUpdate,
    coverUrl: coverUrl,
    needsCover: needsCover
  });

  return (
    <MD3Card 
      ref={cardRef}
      className="enhanced-book-card"
      variant="elevated"
      onClick={handleCardClick}
      onContextMenu={handleContextMenu}
    >
      {/* Book Cover */}
      <div className="book-cover-container" style={{ position: 'relative' }}>
        <img
          src={coverUrl}
          alt={`Cover of ${book.title}`}
          className="book-cover"
          onError={(e) => {
            e.target.src = fallbackCoverUrl;
          }}
        />
        
        {/* Your existing reading status badge */}
        {book.isReading && (
          <div className="reading-badge">
            <span className="reading-icon">ðŸ“–</span>
            Reading
          </div>
        )}

        {/* NEW: Simple "Find Cover" button (only for books that need covers) */}
        {needsCover && (
          <button
            className="update-cover-button"
            onClick={handleFindCover}
            disabled={findingCover}
            title={findingCover ? "Finding cover..." : "Find cover for this book"}
            aria-label="Find book cover"
            style={{
              position: 'absolute',
              bottom: '8px',
              left: '8px',
              background: findingCover ? 'rgba(103, 80, 164, 0.5)' : 'rgba(103, 80, 164, 0.9)',
              color: 'white',
              border: 'none',
              borderRadius: '50%',
              width: '32px',
              height: '32px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              cursor: findingCover ? 'default' : 'pointer',
              fontSize: '14px',
              backdropFilter: 'blur(4px)',
              transition: 'all 0.2s ease',
              zIndex: 2,
              opacity: 0
            }}
          >
            {findingCover ? 'âŸ³' : 'ðŸŽ¨'}
          </button>
        )}

        {/* Your existing action menu button */}
        <button 
          className="card-menu-button"
          onClick={handleMenuClick}
          aria-label="Book actions"
        >
          â‹®
        </button>
      </div>

      {/* Your existing book details section (unchanged) */}
      <div className="book-details">
        <h3 className="book-title">{book.title}</h3>
        <p className="book-author">{book.author}</p>
        
        {/* Your existing progress bar (unchanged) */}
        {book.isReading && book.progress !== undefined && (
          <div className="reading-progress">
            <div className="progress-bar">
              <div 
                className="progress-fill"
                style={{ width: `${book.progress}%` }}
              />
            </div>
            <span className="progress-text">{book.progress}% complete</span>
          </div>
        )}
        
        {/* Your existing metadata (unchanged) */}
        <div className="book-metadata">
          {book.genre && (
            <MD3Chip size="small" variant="outlined">
              {book.genre}
            </MD3Chip>
          )}
          {book.year && (
            <span className="book-year">{book.year}</span>
          )}
        </div>
      </div>

      {/* Your existing context menu */}
      {menuOpen && (
        <MD3BookActionsMenu
          open={menuOpen}
          onClose={() => setMenuOpen(false)}
          anchor={menuAnchor}
          onRead={() => onRead?.(book)}
          onEdit={() => onEdit?.(book)}
          onDelete={() => onDelete?.(book)}
          onShare={() => onShare?.(book)}
          onAddToCollection={() => onAddToCollection?.(book)}
          book={book}
        />
      )}
    </MD3Card>
  );
};

// Search and Filter Bar Component (unchanged from your original)
const SearchAndFilterBar = ({
  searchQuery,
  onSearchChange,
  selectedGenres,
  onGenreChange,
  sortBy,
  onSortChange,
  viewMode,
  onViewModeChange,
  availableGenres
}) => {
  return (
    <div className="search-filter-bar">
      <MD3TextField
        label="Search books..."
        value={searchQuery}
        onChange={(e) => onSearchChange(e.target.value)}
        className="search-input"
        leadingIcon="ðŸ”"
      />

      <MD3ChipGroup
        label="Filter by genre"
        multiSelect
        value={selectedGenres}
        onChange={onGenreChange}
      >
        {availableGenres.map(genre => (
          <MD3Chip key={genre} value={genre}>
            {genre}
          </MD3Chip>
        ))}
      </MD3ChipGroup>

      <div className="view-controls">
        <MD3SortMenu
          value={sortBy}
          onChange={onSortChange}
          options={[
            { value: 'title', label: 'Title' },
            { value: 'author', label: 'Author' },
            { value: 'year', label: 'Year' },
            { value: 'genre', label: 'Genre' },
            { value: 'dateAdded', label: 'Date Added' }
          ]}
        />
        
        <div className="view-mode-toggle">
          <MD3Button
            variant={viewMode === 'grid' ? 'filled' : 'outlined'}
            size="small"
            onClick={() => onViewModeChange('grid')}
          >
            Grid
          </MD3Button>
          <MD3Button
            variant={viewMode === 'list' ? 'filled' : 'outlined'}
            size="small"
            onClick={() => onViewModeChange('list')}
          >
            List
          </MD3Button>
        </div>
      </div>
    </div>
  );
};

// Settings Dialog Component (unchanged from your original)
const SettingsDialog = ({ open, onClose }) => {
  const [darkMode, setDarkMode] = useState(false);
  const [notifications, setNotifications] = useState(true);
  const [autoBackup, setAutoBackup] = useState(false);

  return (
    <MD3Dialog open={open} onClose={onClose} title="Settings">
      <div className="settings-content">
        <div className="setting-item">
          <label>Dark Mode</label>
          <MD3Switch
            checked={darkMode}
            onChange={setDarkMode}
          />
        </div>
        
        <div className="setting-item">
          <label>Enable Notifications</label>
          <MD3Switch
            checked={notifications}
            onChange={setNotifications}
          />
        </div>
        
        <div className="setting-item">
          <label>Auto Backup</label>
          <MD3Switch
            checked={autoBackup}
            onChange={setAutoBackup}
          />
        </div>
      </div>
      
      <MD3DialogActions>
        <MD3Button variant="text" onClick={onClose}>
          Cancel
        </MD3Button>
        <MD3Button variant="filled" onClick={onClose}>
          Save
        </MD3Button>
      </MD3DialogActions>
    </MD3Dialog>
  );
};

// SUPER SAFE Main App Component
const EnhancedBookLibraryApp = ({ books = [], onBookUpdate }) => {
  // Your existing state management (unchanged)
  const [currentPage, setCurrentPage] = useState('library');
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedGenres, setSelectedGenres] = useState([]);
  const [sortBy, setSortBy] = useState('title');
  const [viewMode, setViewMode] = useState('grid');
  const [settingsOpen, setSettingsOpen] = useState(false);

  // NEW: Simple batch update state (optional)
  const [batchUpdating, setBatchUpdating] = useState(false);

  // Your existing hooks
  const { showSnackbar } = useSnackbar();

  // Your existing computed values (unchanged)
  const availableGenres = useMemo(() => {
    const genres = books.map(book => book.genre).filter(Boolean);
    return [...new Set(genres)];
  }, [books]);

  const filteredBooks = useMemo(() => {
    return books.filter(book => {
      const matchesSearch = !searchQuery || 
        book.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
        book.author.toLowerCase().includes(searchQuery.toLowerCase());
      
      const matchesGenre = selectedGenres.length === 0 || 
        selectedGenres.includes(book.genre);
      
      return matchesSearch && matchesGenre;
    });
  }, [books, searchQuery, selectedGenres]);

  const sortedBooks = useMemo(() => {
    const sorted = [...filteredBooks];
    sorted.sort((a, b) => {
      switch (sortBy) {
        case 'title':
          return a.title.localeCompare(b.title);
        case 'author':
          return a.author.localeCompare(b.author);
        case 'year':
          return (b.year || 0) - (a.year || 0);
        case 'genre':
          return (a.genre || '').localeCompare(b.genre || '');
        case 'dateAdded':
          return new Date(b.dateAdded || 0) - new Date(a.dateAdded || 0);
        default:
          return 0;
      }
    });
    return sorted;
  }, [filteredBooks, sortBy]);

  const readingBooks = useMemo(() => {
    return books.filter(book => book.isReading);
  }, [books]);

  // NEW: Count books that need covers
  const booksNeedingCovers = useMemo(() => {
    return books.filter(book => !book.cover && !book.cover_url);
  }, [books]);

  // Your existing event handlers (unchanged)
  const handleBookRead = (book) => {
    console.log('ðŸ“– Reading book:', book.title);
    onBookUpdate?.('read', book);
  };

  const handleBookEdit = (book) => {
    console.log('âœï¸ Editing book:', book.title);
    onBookUpdate?.('edit', book);
  };

  const handleBookDelete = (book) => {
    console.log('ðŸ—‘ï¸ Deleting book:', book.title);
    onBookUpdate?.('delete', book);
  };

  // NEW: SAFE batch cover update (manual, no hooks)
  const handleBatchUpdateCovers = async () => {
    if (batchUpdating) return;
    
    const booksToUpdate = booksNeedingCovers.slice(0, 5); // Limit to 5 at a time
    
    if (booksToUpdate.length === 0) {
      showSnackbar({
        message: 'No books need cover updates!',
        variant: 'info'
      });
      return;
    }

    setBatchUpdating(true);
    
    try {
      showSnackbar({
        message: `Finding covers for ${booksToUpdate.length} books...`,
        variant: 'info'
      });

      let successCount = 0;
      
      // Process books one by one (safe and controlled)
      for (const book of booksToUpdate) {
        try {
          const coverData = await bookCoverService.getBookData(
            book.title, 
            book.author, 
            book.isbn
          );

          if (coverData && coverData.cover && coverData.source !== 'placeholder') {
            onBookUpdate?.('updateCover', {
              ...book,
              cover_url: coverData.cover,
              cover_small_url: coverData.coverSmall,
              cover_medium_url: coverData.coverMedium,
              cover_large_url: coverData.coverLarge,
              api_source: coverData.source,
              enhanced_metadata: {
                description: coverData.description,
                categories: coverData.categories,
                published_date: coverData.publishedDate,
                page_count: coverData.pageCount
              }
            });
            successCount++;
          }

          // Small delay to be respectful to APIs
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (error) {
          console.error(`Failed to get cover for ${book.title}:`, error);
        }
      }

      showSnackbar({
        message: `âœ… Updated ${successCount} of ${booksToUpdate.length} covers!`,
        variant: 'success'
      });
      
    } catch (error) {
      showSnackbar({
        message: `Batch update failed: ${error.message}`,
        variant: 'error'
      });
    } finally {
      setBatchUpdating(false);
    }
  };

  // Your existing navigation items (unchanged)
  const navigationItems = [
    { id: 'library', label: 'Library', icon: 'ðŸ“š' },
    { id: 'reading', label: 'Reading', icon: 'ðŸ“–' },
    { id: 'collections', label: 'Collections', icon: 'ðŸ“‚' },
    { id: 'stats', label: 'Statistics', icon: 'ðŸ“Š' }
  ];

  // SAFE render page content with optional batch update
  const renderPageContent = () => {
    switch (currentPage) {
      case 'library':
        return (
          <div className="library-page">
            <div className="page-header">
              <h1>My Library</h1>
              <div className="header-actions">
                {/* NEW: Optional batch update button */}
                {booksNeedingCovers.length > 0 && (
                  <MD3Button
                    variant="outlined"
                    icon="ðŸŽ¨"
                    onClick={handleBatchUpdateCovers}
                    disabled={batchUpdating}
                  >
                    {batchUpdating 
                      ? 'Finding Covers...'
                      : `Find ${Math.min(booksNeedingCovers.length, 5)} Covers`
                    }
                  </MD3Button>
                )}
                
                <MD3Button
                  variant="outlined"
                  icon="âš™ï¸"
                  onClick={() => setSettingsOpen(true)}
                >
                  Settings
                </MD3Button>
              </div>
            </div>

            <SearchAndFilterBar
              searchQuery={searchQuery}
              onSearchChange={setSearchQuery}
              selectedGenres={selectedGenres}
              onGenreChange={setSelectedGenres}
              sortBy={sortBy}
              onSortChange={setSortBy}
              viewMode={viewMode}
              onViewModeChange={setViewMode}
              availableGenres={availableGenres}
            />

            <div className={`books-container books-container--${viewMode}`} style={{
              display: 'grid',
              gridTemplateColumns: viewMode === 'grid' ? 'repeat(auto-fill, minmax(200px, 1fr))' : '1fr',
              gap: '20px',
              marginTop: '20px'
            }}>
              {sortedBooks.length > 0 ? (
                sortedBooks.map(book => (
                  <EnhancedBookCard
                    key={book.id}
                    book={book}
                    onRead={handleBookRead}
                    onEdit={handleBookEdit}
                    onDelete={handleBookDelete}
                    onShare={(book) => showSnackbar({ 
                      message: `Sharing "${book.title}"`, 
                      variant: 'info' 
                    })}
                    onAddToCollection={(book) => showSnackbar({ 
                      message: `Added "${book.title}" to collection`, 
                      variant: 'success' 
                    })}
                    onBookUpdate={onBookUpdate}
                  />
                ))
              ) : (
                <div className="empty-state" style={{
                  textAlign: 'center',
                  padding: '40px',
                  color: '#666'
                }}>
                  <h3>No books found</h3>
                  <p>Try adjusting your search or filter criteria</p>
                </div>
              )}
            </div>
          </div>
        );

      case 'reading':
        return (
          <div className="reading-page">
            <div className="page-header">
              <h1>Currently Reading</h1>
              <p className="page-subtitle">
                {readingBooks.length} book{readingBooks.length !== 1 ? 's' : ''} in progress
              </p>
            </div>
            
            <div className="reading-books" style={{
              display: 'grid',
              gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
              gap: '20px',
              marginTop: '20px'
            }}>
              {readingBooks.length > 0 ? (
                readingBooks.map(book => (
                  <EnhancedBookCard
                    key={book.id}
                    book={book}
                    onRead={handleBookRead}
                    onEdit={handleBookEdit}
                    onDelete={handleBookDelete}
                    onShare={(book) => showSnackbar({ 
                      message: `Sharing "${book.title}"`, 
                      variant: 'info' 
                    })}
                    onAddToCollection={(book) => showSnackbar({ 
                      message: `Added "${book.title}" to collection`, 
                      variant: 'success' 
                    })}
                    onBookUpdate={onBookUpdate}
                  />
                ))
              ) : (
                <div className="empty-state" style={{
                  textAlign: 'center',
                  padding: '40px',
                  color: '#666'
                }}>
                  <h3>No books currently being read</h3>
                  <p>Click "Start Reading" on any book to add it here!</p>
                </div>
              )}
            </div>
          </div>
        );

      case 'collections':
        return (
          <div className="collections-page">
            <h1>Collections</h1>
            <p>Feature coming soon!</p>
          </div>
        );

      case 'stats':
        return (
          <div className="stats-page">
            <h1>Reading Statistics</h1>
            <p>Feature coming soon!</p>
          </div>
        );

      default:
        return (
          <div>
            <h1>Page not found</h1>
          </div>
        );
    }
  };

  return (
    <div className="enhanced-book-library-app">
      {/* Navigation Tabs */}
      <div style={{
        display: 'flex',
        gap: '8px',
        marginBottom: '24px',
        borderBottom: '1px solid #e0e0e0',
        paddingBottom: '8px'
      }}>
        {navigationItems.map(item => (
          <button
            key={item.id}
            onClick={() => setCurrentPage(item.id)}
            style={{
              padding: '12px 16px',
              border: 'none',
              borderRadius: '8px',
              backgroundColor: currentPage === item.id ? '#6750a4' : 'transparent',
              color: currentPage === item.id ? 'white' : '#666',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '8px',
              fontSize: '14px',
              fontWeight: currentPage === item.id ? '600' : '400',
              transition: 'all 0.2s ease'
            }}
          >
            <span>{item.icon}</span>
            <span>{item.label}</span>
          </button>
        ))}
      </div>

      {/* Page Content */}
      {renderPageContent()}

      {/* Settings Dialog */}
      <SettingsDialog 
        open={settingsOpen} 
        onClose={() => setSettingsOpen(false)} 
      />
    </div>
  );
};

export default EnhancedBookLibraryApp;