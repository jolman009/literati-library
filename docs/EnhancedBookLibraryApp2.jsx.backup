// Complete EnhancedBookLibraryApp.jsx with all features restored
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { StartReadingButton } from '../components/ReadingSessionUI';


// Context and Hooks
import { useGamification } from '../contexts/GamificationContext';
import { useAuth } from '../contexts/AuthContext';
import { useSnackbar } from '../components/Material3';

// Components
import GamificationDashboard from './gamification/GamificationDashboard';
import EnhancedWelcomeComponent from './EnhancedWelcomeComponent';

// Material Design 3 Components
import {
  MD3Card,
  MD3Button,
  MD3TextField,
  MD3Chip,
  MD3ChipGroup,
  MD3Dialog,
  MD3DialogActions,
  MD3Switch,
  MD3Menu,
  MD3MenuItem,
  MD3MenuDivider,
  MD3SortMenu,
  MD3BookActionsMenu,
  MD3FloatingActionButton,
  MD3BookLibraryFab,
  MD3Progress,
  CircularProgress,
  useThemeColors
} from '../components/Material3';

// CSS
import './EnhancedBookLibraryApp.css';

// Enhanced Book Card Component with Full Functionality
const EnhancedBookCard = ({ 
  book, 
  viewMode = 'grid', 
  onRead, 
  onStartReading, 
  onStopReading,
  onEdit,
  onDelete,
  onMenuAction,
  className = ''
}) => {
  const [showMenu, setShowMenu] = useState(false);

  const handleCardClick = (e) => {
    // Only trigger if not clicking on menu button or menu items
    if (e.target.closest('.menu-button') || e.target.closest('.book-menu')) {
      return;
    }
    
    console.log('üìñ Card clicked, opening book:', book.title);
    onRead?.(book);
  };

  const handleMenuClick = (e) => {
    e.stopPropagation(); // Prevent card click
    setShowMenu(!showMenu);
  };

  const handleMenuAction = (action) => {
    console.log(`üé¨ Menu action: ${action} for book:`, book.title);
    setShowMenu(false);
    
    switch (action) {
      case 'read':
        onRead?.(book);
        break;
      case 'start-reading':
        onStartReading?.(book);
        break;
      case 'stop-reading':
        onStopReading?.(book);
        break;
      case 'edit':
        onEdit?.(book);
        break;
      case 'delete':
        onDelete?.(book);
        break;
      default:
        onMenuAction?.(action, book);
    }
  };

  return (
    <div className={`enhanced-book-card ${viewMode} ${className}`}>
      {/* ‚úÖ FIXED: Main card area as DIV with click handler, not button */}
      <div 
        className="book-card-content"
        onClick={handleCardClick}
        style={{
          borderRadius: '12px',
          background: 'rgb(var(--md-sys-color-surface-container-low))',
          border: '1px solid rgb(var(--md-sys-color-outline-variant))',
          padding: '16px',
          cursor: 'pointer',
          transition: 'all 0.2s ease',
          position: 'relative'
        }}
        onMouseEnter={(e) => {
          e.currentTarget.style.boxShadow = 'var(--md-sys-elevation-level2)';
          e.currentTarget.style.transform = 'translateY(-2px)';
        }}
        onMouseLeave={(e) => {
          e.currentTarget.style.boxShadow = 'none';
          e.currentTarget.style.transform = 'translateY(0)';
        }}
      >
        {/* Book Cover */}
        <div className="book-cover" style={{ 
          marginBottom: '12px', 
          position: 'relative',
          borderRadius: '8px',
          overflow: 'hidden',
          aspectRatio: '3/4',
          backgroundColor: '#f0f0f0'
        }}>
          {book.cover_url ? (
            <img 
              src={book.cover_url} 
              alt={`${book.title} cover`}
              style={{
                width: '100%',
                height: '100%',
                objectFit: 'cover'
              }}
              onError={(e) => {
                e.target.style.display = 'none';
                if (e.target.nextSibling) {
                  e.target.nextSibling.style.display = 'flex';
                }
              }}
            />
          ) : null}
          
          {/* Fallback cover */}
          <div style={{
            display: book.cover_url ? 'none' : 'flex',
            width: '100%',
            height: '100%',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: '#e3f2fd',
            flexDirection: 'column',
            gap: '8px'
          }}>
            <span style={{ fontSize: '24px' }}>üìö</span>
            <span style={{ 
              fontSize: '10px', 
              textAlign: 'center', 
              padding: '0 4px',
              fontWeight: '500'
            }}>
              {book.title?.substring(0, 20)}
              {book.title?.length > 20 ? '...' : ''}
            </span>
          </div>

          {/* ‚úÖ FIXED: Menu button positioned absolutely, not nested in main button */}
          <button
            className="menu-button"
            onClick={handleMenuClick}
            aria-label="Book actions"
            style={{
              position: 'absolute',
              top: '8px',
              right: '8px',
              width: '32px',
              height: '32px',
              borderRadius: '50%',
              border: 'none',
              backgroundColor: 'rgba(0, 0, 0, 0.6)',
              color: 'white',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: '16px',
              zIndex: 10
            }}
          >
            ‚ãÆ
          </button>

          {/* Reading status indicator */}
          {book.isReading && (
            <div style={{
              position: 'absolute',
              bottom: '8px',
              left: '8px',
              backgroundColor: '#4caf50',
              color: 'white',
              padding: '4px 8px',
              borderRadius: '12px',
              fontSize: '10px',
              fontWeight: '500'
            }}>
              Reading
            </div>
          )}
        </div>

        {/* Book Info */}
        <div className="book-info" style={{ textAlign: 'left' }}>
          <h3 style={{ 
            margin: '0 0 4px 0', 
            fontSize: '14px',
            fontWeight: '600',
            lineHeight: '1.2',
            color: 'rgb(var(--md-sys-color-on-surface))'
          }}>
            {book.title}
          </h3>
          {book.author && (
            <p style={{ 
              margin: '0 0 8px 0', 
              fontSize: '12px',
              color: 'rgb(var(--md-sys-color-on-surface-variant))'
            }}>
              {book.author}
            </p>
          )}
          
          {/* Progress bar if reading */}
          {book.isReading && book.progress !== undefined && (
            <div style={{
              marginTop: '8px',
              backgroundColor: 'rgb(var(--md-sys-color-surface-container-highest))',
              borderRadius: '4px',
              height: '4px',
              overflow: 'hidden'
            }}>
              <div style={{
                width: `${book.progress || 0}%`,
                height: '100%',
                backgroundColor: 'rgb(var(--md-sys-color-primary))',
                transition: 'width 0.3s ease'
              }} />
            </div>
          )}
        </div>
      </div>

      {/* Dropdown Menu */}
      {showMenu && (
        <div 
          className="book-menu"
          style={{
            position: 'absolute',
            top: '56px',
            right: '8px',
            backgroundColor: 'white',
            borderRadius: '8px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
            minWidth: '160px',
            zIndex: 100,
            overflow: 'hidden'
          }}
        >
          <button
            onClick={() => handleMenuAction('read')}
            style={{
              width: '100%',
              padding: '12px 16px',
              border: 'none',
              backgroundColor: 'transparent',
              textAlign: 'left',
              cursor: 'pointer',
              fontSize: '14px'
            }}
            onMouseEnter={(e) => e.target.style.backgroundColor = '#f5f5f5'}
            onMouseLeave={(e) => e.target.style.backgroundColor = 'transparent'}
          >
            üìñ Read
          </button>
          
          {book.isReading ? (
            <button
              onClick={() => handleMenuAction('stop-reading')}
              style={{
                width: '100%',
                padding: '12px 16px',
                border: 'none',
                backgroundColor: 'transparent',
                textAlign: 'left',
                cursor: 'pointer',
                fontSize: '14px'
              }}
              onMouseEnter={(e) => e.target.style.backgroundColor = '#f5f5f5'}
              onMouseLeave={(e) => e.target.style.backgroundColor = 'transparent'}
            >
              ‚èπÔ∏è Stop Reading
            </button>
          ) : (
            <button
              onClick={() => handleMenuAction('start-reading')}
              style={{
                width: '100%',
                padding: '12px 16px',
                border: 'none',
                backgroundColor: 'transparent',
                textAlign: 'left',
                cursor: 'pointer',
                fontSize: '14px'
              }}
              onMouseEnter={(e) => e.target.style.backgroundColor = '#f5f5f5'}
              onMouseLeave={(e) => e.target.style.backgroundColor = 'transparent'}
            >
              ‚ñ∂Ô∏è Start Reading
            </button>
          )}
          
          <hr style={{ margin: 0, border: 'none', borderTop: '1px solid #eee' }} />
          
          <button
            onClick={() => handleMenuAction('edit')}
            style={{
              width: '100%',
              padding: '12px 16px',
              border: 'none',
              backgroundColor: 'transparent',
              textAlign: 'left',
              cursor: 'pointer',
              fontSize: '14px'
            }}
            onMouseEnter={(e) => e.target.style.backgroundColor = '#f5f5f5'}
            onMouseLeave={(e) => e.target.style.backgroundColor = 'transparent'}
          >
            ‚úèÔ∏è Edit
          </button>
          
          <button
            onClick={() => handleMenuAction('delete')}
            style={{
              width: '100%',
              padding: '12px 16px',
              border: 'none',
              backgroundColor: 'transparent',
              textAlign: 'left',
              cursor: 'pointer',
              fontSize: '14px',
              color: '#d32f2f'
            }}
            onMouseEnter={(e) => e.target.style.backgroundColor = '#ffebee'}
            onMouseLeave={(e) => e.target.style.backgroundColor = 'transparent'}
          >
            üóëÔ∏è Delete
          </button>
        </div>
      )}

      {/* Click outside to close menu */}
      {showMenu && (
        <div
          style={{
            position: 'fixed',
            inset: 0,
            zIndex: 99
          }}
          onClick={() => setShowMenu(false)}
        />
      )}
    </div>
  );
};

// Reading Statistics Card with Error Handling
const ReadingStatsCard = ({ books = [], analytics = {} }) => {
  const totalBooks = books.length;
  const readingBooks = books.filter(book => book.isReading).length;
  const completedBooks = books.filter(book => book.status === 'completed').length;
  
  const readingStreak = analytics.currentStreak || 0;
  const avgReadingTime = analytics.averageSessionDuration || '0 min';
  const totalReadingTime = analytics.totalReadingTime || '0 hours';
  const favoriteGenre = analytics.favoriteGenre || 'None';

  return (
    <div className="stats-grid">
      <div className="stats-card">
        <h3>Library Size</h3>
        <p className="primary">{totalBooks}</p>
      </div>
      
      <div className="stats-card">
        <h3>Currently Reading</h3>
        <p className="success">{readingBooks}</p>
      </div>
      
      <div className="stats-card">
        <h3>Completed</h3>
        <p className="success">{completedBooks}</p>
      </div>
      
      <div className="stats-card">
        <h3>Reading Streak</h3>
        <p className="warning">{readingStreak} days</p>
      </div>
      
      <div className="stats-card">
        <h3>Avg. Session</h3>
        <p>{avgReadingTime}</p>
      </div>
      
      <div className="stats-card">
        <h3>Total Time</h3>
        <p>{totalReadingTime}</p>
      </div>
      
      <div className="stats-card">
        <h3>Favorite Genre</h3>
        <p>{favoriteGenre}</p>
      </div>
      
      <div className="stats-card">
        <h3>Completion Rate</h3>
        <p className="primary">{totalBooks > 0 ? Math.round((completedBooks / totalBooks) * 100) : 0}%</p>
      </div>
    </div>
  );
};

// Enhanced Reading Statistics Card with Gamification Integration
const EnhancedReadingStatsCard = ({ books = [], analytics = {} }) => {
  const [gamificationError, setGamificationError] = useState(false);
  let stats = {};
  let gamificationAvailable = false;
  
  try {
    const gamificationData = useGamification();
    stats = gamificationData?.stats || {};
    gamificationAvailable = true;
  } catch (error) {
    console.warn('Gamification system not available:', error);
    setGamificationError(true);
    gamificationAvailable = false;
  }
  
  const totalBooks = books.length;
  const readingBooks = books.filter(book => book.isReading).length;
  const completedBooks = books.filter(book => book.status === 'completed').length;
  
  // Use gamification stats when available, fallback to analytics
  const totalReadingMinutes = stats.totalReadingTime || analytics.totalReadingTime || 0;
  const totalReadingHours = Math.floor(totalReadingMinutes / 60);
  const remainingMinutes = totalReadingMinutes % 60;
  
  const readingStreak = stats.readingStreak || analytics.currentStreak || 0;
  const avgReadingTime = analytics.averageSessionDuration || '0 min';
  const favoriteGenre = analytics.favoriteGenre || 'None';

  return (
    <div className="enhanced-stats-container">
      {/* Error State Display */}
      {gamificationError && (
        <div className="gamification-error-banner">
          <span>‚ö†Ô∏è Enhanced features temporarily unavailable</span>
          <button onClick={() => window.location.reload()}>Retry</button>
        </div>
      )}

      <div className="stats-grid enhanced">
        {/* Basic Stats */}
        <div className="stats-card primary">
          <h3>Library Size</h3>
          <p className="primary">{totalBooks}</p>
        </div>
        
        <div className="stats-card success">
          <h3>Currently Reading</h3>
          <p className="success">{readingBooks}</p>
        </div>
        
        <div className="stats-card success">
          <h3>Completed</h3>
          <p className="success">{completedBooks}</p>
        </div>
        
        <div className="stats-card warning">
          <h3>Reading Streak</h3>
          <p className="warning">üî• {readingStreak} days</p>
        </div>
        
        <div className="stats-card">
          <h3>Avg. Session</h3>
          <p>{avgReadingTime}</p>
        </div>
        
        <div className="stats-card">
          <h3>Total Time</h3>
          <p>{totalReadingHours > 0 ? `${totalReadingHours}h ${remainingMinutes}m` : '0 hours'}</p>
        </div>
        
        <div className="stats-card">
          <h3>Favorite Genre</h3>
          <p>{favoriteGenre}</p>
        </div>
        
        <div className="stats-card">
          <h3>Completion Rate</h3>
          <p className="primary">{totalBooks > 0 ? Math.round((completedBooks / totalBooks) * 100) : 0}%</p>
        </div>

        {/* Enhanced Gamification Stats */}
        {gamificationAvailable && !gamificationError && (
          <>
            <div className="stats-card enhanced">
              <h3>Level</h3>
              <p className="primary">Level {stats.level || 1}</p>
            </div>
            
            <div className="stats-card enhanced">
              <h3>Total Points</h3>
              <p className="success">{stats.totalPoints || 0}</p>
            </div>
            
            <div className="stats-card enhanced">
              <h3>Notes Created</h3>
              <p className="warning">{stats.notesCreated || 0}</p>
            </div>
            
            <div className="stats-card enhanced">
              <h3>Highlights</h3>
              <p className="error">{stats.highlightsCreated || 0}</p>
            </div>
          </>
        )}
      </div>
    </div>
  );
};

// Enhanced Stats Page with Complete Integration
const EnhancedStatsPage = ({ books = [], analytics = {} }) => {
  const [gamificationAvailable, setGamificationAvailable] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Check gamification availability
    try {
      const gamificationData = useGamification();
      setGamificationAvailable(true);
    } catch (error) {
      console.warn('Gamification not available for stats page');
      setGamificationAvailable(false);
    } finally {
      setLoading(false);
    }
  }, []);

  if (loading) {
    return (
      <div className="stats-loading">
        <CircularProgress />
        <p>Loading statistics...</p>
      </div>
    );
  }

  return (
    <div className="stats-page">
      <div className="page-header">
        <h1>üìä Reading Statistics</h1>
        <p>Track your progress, monitor reading time, and unlock achievements</p>
      </div>
      
      {/* Enhanced Reading Statistics */}
      <EnhancedReadingStatsCard books={books} analytics={analytics} />
      
      {/* Gamification Dashboard */}
      {gamificationAvailable ? (
        <div className="gamification-section">
          <GamificationDashboard />
        </div>
      ) : (
        <div className="gamification-fallback">
          <MD3Card variant="outlined" className="coming-soon-card">
            <div className="coming-soon-content">
              <h3>üéØ Enhanced Features</h3>
              <p>Level up your reading experience with achievements, goals, and detailed analytics!</p>
              <div className="feature-list">
                <div className="feature-item">üèÜ Unlock achievements</div>
                <div className="feature-item">üìà Track detailed progress</div>
                <div className="feature-item">üéØ Set reading goals</div>
                <div className="feature-item">üî• Build reading streaks</div>
              </div>
              <MD3Button variant="outlined">Coming Soon</MD3Button>
            </div>
          </MD3Card>
        </div>
      )}

      {/* Reading Insights */}
      <div className="reading-insights">
        <h2>üìà Reading Insights</h2>
        <div className="insights-grid">
          <MD3Card className="insight-card">
            <h4>This Month</h4>
            <p>You've read {books.filter(b => b.isReading).length} books this month!</p>
          </MD3Card>
          <MD3Card className="insight-card">
            <h4>Favorite Time</h4>
            <p>You read most often in the evening</p>
          </MD3Card>
          <MD3Card className="insight-card">
            <h4>Reading Goal</h4>
            <p>You're 67% towards your yearly goal</p>
          </MD3Card>
        </div>
      </div>
    </div>
  );
};

// Advanced Search and Filter Bar
const SearchAndFilterBar = ({
  searchQuery,
  onSearchChange,
  selectedGenres,
  onGenreChange,
  sortBy,
  onSortChange,
  viewMode,
  onViewModeChange,
  availableGenres = [],
  booksNeedingCovers = 0,
  onBatchUpdateCovers,
  batchUpdating = false,
  batchMode = false,
  onToggleBatchMode,
  selectedBooks = [],
  onBatchAction
}) => {
  const [advancedOpen, setAdvancedOpen] = useState(false);
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [ratingFilter, setRatingFilter] = useState('');

  return (
    <div className="search-filter-bar">
      {/* Main Search Row */}
      <div className="search-row">
        <MD3TextField
          label="Search books..."
          value={searchQuery}
          onChange={(e) => onSearchChange(e.target.value)}
          className="search-input"
          leadingIcon="üîç"
          placeholder="Title, author, or genre..."
        />

        <MD3Button
          variant="outlined"
          onClick={() => setAdvancedOpen(!advancedOpen)}
          trailingIcon={advancedOpen ? "üîº" : "üîΩ"}
        >
          Advanced
        </MD3Button>

        <div className="view-controls">
          <MD3Button
            variant={viewMode === 'grid' ? 'filled' : 'outlined'}
            size="small"
            onClick={() => onViewModeChange('grid')}
            icon="‚äû"
          >
            Grid
          </MD3Button>
          <MD3Button
            variant={viewMode === 'list' ? 'filled' : 'outlined'}
            size="small"
            onClick={() => onViewModeChange('list')}
            icon="‚ò∞"
          >
            List
          </MD3Button>
        </div>
      </div>

      {/* Filter Row */}
      <div className="filter-row">
        {/* Genre Filter */}
        {availableGenres.length > 0 && (
          <MD3ChipGroup
            label="Genres"
            multiSelect
            value={selectedGenres}
            onChange={onGenreChange}
          >
            {availableGenres.map(genre => (
              <MD3Chip key={genre} value={genre} variant="filter">
                {genre}
              </MD3Chip>
            ))}
          </MD3ChipGroup>
        )}

        {/* Sort Menu */}
        <MD3SortMenu
          value={sortBy}
          onChange={onSortChange}
          options={[
            { value: 'title', label: 'Title (A-Z)' },
            { value: 'title-desc', label: 'Title (Z-A)' },
            { value: 'author', label: 'Author (A-Z)' },
            { value: 'author-desc', label: 'Author (Z-A)' },
            { value: 'year', label: 'Year (Newest)' },
            { value: 'year-desc', label: 'Year (Oldest)' },
            { value: 'genre', label: 'Genre' },
            { value: 'dateAdded', label: 'Recently Added' },
            { value: 'dateAdded-desc', label: 'Oldest Added' },
            { value: 'progress', label: 'Reading Progress' },
            { value: 'rating', label: 'Rating' }
          ]}
        />
      </div>

      {/* Advanced Filters */}
      {advancedOpen && (
        <div className="advanced-filters">
          <div className="advanced-row">
            <MD3TextField
              label="Date Range Start"
              type="date"
              value={dateRange.start}
              onChange={(e) => setDateRange(prev => ({ ...prev, start: e.target.value }))}
            />
            <MD3TextField
              label="Date Range End"
              type="date"
              value={dateRange.end}
              onChange={(e) => setDateRange(prev => ({ ...prev, end: e.target.value }))}
            />
            <MD3TextField
              label="Minimum Rating"
              type="number"
              min="1"
              max="5"
              value={ratingFilter}
              onChange={(e) => setRatingFilter(e.target.value)}
            />
          </div>
        </div>
      )}

      {/* Batch Operations */}
      <div className="batch-operations">
        <div className="batch-controls">
          <MD3Button
            variant={batchMode ? 'filled' : 'outlined'}
            onClick={onToggleBatchMode}
            icon={batchMode ? "‚úì" : "‚òê"}
          >
            {batchMode ? `Selected (${selectedBooks.length})` : 'Select Multiple'}
          </MD3Button>

          {batchMode && selectedBooks.length > 0 && (
            <div className="batch-actions">
              <MD3Button
                variant="outlined"
                onClick={() => onBatchAction('edit')}
                icon="‚úèÔ∏è"
              >
                Edit Selected
              </MD3Button>
              <MD3Button
                variant="outlined"
                onClick={() => onBatchAction('collection')}
                icon="üìÅ"
              >
                Add to Collection
              </MD3Button>
              <MD3Button
                variant="outlined"
                onClick={() => onBatchAction('delete')}
                icon="üóëÔ∏è"
              >
                Delete Selected
              </MD3Button>
            </div>
          )}
        </div>

        {/* Cover Update Action */}
        {booksNeedingCovers > 0 && (
          <MD3Button
            variant="outlined"
            onClick={onBatchUpdateCovers}
            loading={batchUpdating}
            icon="üñºÔ∏è"
          >
            {batchUpdating ? 'Updating...' : `Update ${booksNeedingCovers} Covers`}
          </MD3Button>
        )}
      </div>
    </div>
  );
};

// Settings Dialog with Complete Options
const SettingsDialog = ({ open, onClose }) => {
  const [settings, setSettings] = useState({
    // Appearance
    darkMode: false,
    compactMode: false,
    showProgress: true,
    showMetadata: true,
    
    // Behavior
    autoMarkReading: true,
    confirmDeletion: true,
    autoSave: true,
    
    // Notifications
    notifications: true,
    readingReminders: false,
    goalReminders: true,
    
    // Data
    autoBackup: false,
    syncEnabled: false,
    offlineMode: false,
    
    // Privacy
    shareProgress: false,
    publicProfile: false
  });

  const handleSettingChange = (key, value) => {
    setSettings(prev => ({ ...prev, [key]: value }));
  };

  const handleSave = () => {
    // Save settings to localStorage or API
    localStorage.setItem('literati-settings', JSON.stringify(settings));
    onClose();
  };

  const handleReset = () => {
    setSettings({
      darkMode: false,
      compactMode: false,
      showProgress: true,
      showMetadata: true,
      autoMarkReading: true,
      confirmDeletion: true,
      autoSave: true,
      notifications: true,
      readingReminders: false,
      goalReminders: true,
      autoBackup: false,
      syncEnabled: false,
      offlineMode: false,
      shareProgress: false,
      publicProfile: false
    });
  };

  return (
    <MD3Dialog open={open} onClose={onClose} title="Settings" className="settings-dialog">
      <div className="settings-content">
        {/* Appearance Settings */}
        <div className="setting-group">
          <h3>Appearance</h3>
          <div className="setting-item">
            <label>
              <span>Dark Mode</span>
              <p>Use dark theme for better reading in low light</p>
            </label>
            <MD3Switch
              checked={settings.darkMode}
              onChange={(e) => handleSettingChange('darkMode', e.target.checked)}
              showIcons
            />
          </div>
          
          <div className="setting-item">
            <label>
              <span>Compact Mode</span>
              <p>Show more books in less space</p>
            </label>
            <MD3Switch
              checked={settings.compactMode}
              onChange={(e) => handleSettingChange('compactMode', e.target.checked)}
            />
          </div>

          <div className="setting-item">
            <label>
              <span>Show Reading Progress</span>
              <p>Display progress bars on book cards</p>
            </label>
            <MD3Switch
              checked={settings.showProgress}
              onChange={(e) => handleSettingChange('showProgress', e.target.checked)}
            />
          </div>

          <div className="setting-item">
            <label>
              <span>Show Book Metadata</span>
              <p>Display genre, year, and page count</p>
            </label>
            <MD3Switch
              checked={settings.showMetadata}
              onChange={(e) => handleSettingChange('showMetadata', e.target.checked)}
            />
          </div>
        </div>

        {/* Behavior Settings */}
        <div className="setting-group">
          <h3>Behavior</h3>
          <div className="setting-item">
            <label>
              <span>Auto-mark as Reading</span>
              <p>Automatically mark books as reading when opened</p>
            </label>
            <MD3Switch
              checked={settings.autoMarkReading}
              onChange={(e) => handleSettingChange('autoMarkReading', e.target.checked)}
            />
          </div>
          
          <div className="setting-item">
            <label>
              <span>Confirm Deletions</span>
              <p>Ask for confirmation before deleting books</p>
            </label>
            <MD3Switch
              checked={settings.confirmDeletion}
              onChange={(e) => handleSettingChange('confirmDeletion', e.target.checked)}
            />
          </div>

          <div className="setting-item">
            <label>
              <span>Auto Save</span>
              <p>Automatically save reading progress</p>
            </label>
            <MD3Switch
              checked={settings.autoSave}
              onChange={(e) => handleSettingChange('autoSave', e.target.checked)}
            />
          </div>
        </div>

        {/* Notification Settings */}
        <div className="setting-group">
          <h3>Notifications</h3>
          <div className="setting-item">
            <label>
              <span>Enable Notifications</span>
              <p>Show notifications for achievements and updates</p>
            </label>
            <MD3Switch
              checked={settings.notifications}
              onChange={(e) => handleSettingChange('notifications', e.target.checked)}
            />
          </div>
          
          <div className="setting-item">
            <label>
              <span>Reading Reminders</span>
              <p>Remind you to read daily</p>
            </label>
            <MD3Switch
              checked={settings.readingReminders}
              onChange={(e) => handleSettingChange('readingReminders', e.target.checked)}
            />
          </div>

          <div className="setting-item">
            <label>
              <span>Goal Reminders</span>
              <p>Notify about reading goal progress</p>
            </label>
            <MD3Switch
              checked={settings.goalReminders}
              onChange={(e) => handleSettingChange('goalReminders', e.target.checked)}
            />
          </div>
        </div>

        {/* Data & Sync Settings */}
        <div className="setting-group">
          <h3>Data & Sync</h3>
          <div className="setting-item">
            <label>
              <span>Auto Backup</span>
              <p>Automatically backup your library to cloud</p>
            </label>
            <MD3Switch
              checked={settings.autoBackup}
              onChange={(e) => handleSettingChange('autoBackup', e.target.checked)}
            />
          </div>
          
          <div className="setting-item">
            <label>
              <span>Sync Enabled</span>
              <p>Sync reading progress across devices</p>
            </label>
            <MD3Switch
              checked={settings.syncEnabled}
              onChange={(e) => handleSettingChange('syncEnabled', e.target.checked)}
            />
          </div>

          <div className="setting-item">
            <label>
              <span>Offline Mode</span>
              <p>Enable offline reading and sync when online</p>
            </label>
            <MD3Switch
              checked={settings.offlineMode}
              onChange={(e) => handleSettingChange('offlineMode', e.target.checked)}
            />
          </div>
        </div>

        {/* Privacy Settings */}
        <div className="setting-group">
          <h3>Privacy</h3>
          <div className="setting-item">
            <label>
              <span>Share Reading Progress</span>
              <p>Allow others to see your reading progress</p>
            </label>
            <MD3Switch
              checked={settings.shareProgress}
              onChange={(e) => handleSettingChange('shareProgress', e.target.checked)}
            />
          </div>
          
          <div className="setting-item">
            <label>
              <span>Public Profile</span>
              <p>Make your reading profile visible to others</p>
            </label>
            <MD3Switch
              checked={settings.publicProfile}
              onChange={(e) => handleSettingChange('publicProfile', e.target.checked)}
            />
          </div>
        </div>
      </div>
      
      <MD3DialogActions>
        <MD3Button variant="text" onClick={handleReset}>
          Reset to Defaults
        </MD3Button>
        <MD3Button variant="text" onClick={onClose}>
          Cancel
        </MD3Button>
        <MD3Button variant="filled" onClick={handleSave}>
          Save Settings
        </MD3Button>
      </MD3DialogActions>
    </MD3Dialog>
  );
};

// Enhanced Navigation Header with Full Features
const EnhancedNavigationHeader = ({
  currentPage,
  onPageChange,
  user,
  onSettings,
  onProfile,
  onNotifications,
  notifications = [],
  quickStats = {}
}) => {
  const [profileMenuOpen, setProfileMenuOpen] = useState(false);
  const [notificationMenuOpen, setNotificationMenuOpen] = useState(false);
  const { getRgb } = useThemeColors();

  const navigationItems = [
    { id: 'library', label: 'Library', icon: 'üìö', count: quickStats.totalBooks },
    { id: 'reading', label: 'Reading', icon: 'üìñ', count: quickStats.currentlyReading },
    { id: 'stats', label: 'Statistics', icon: 'üìä' },
    { id: 'collections', label: 'Collections', icon: 'üìÅ', count: quickStats.collections },
    { id: 'notes', label: 'Notes', icon: 'üìù', count: quickStats.notes }
  ];

  const unreadNotifications = notifications.filter(n => !n.read).length;

  return (
    <header className="enhanced-navigation-header">
      <div className="nav-container">
        {/* Brand Section */}
        <div className="nav-brand">
          <h1>üìö Literati</h1>
          <span className="tagline">Your Digital Bookshelf</span>
        </div>

        {/* Navigation Items */}
        <nav className="nav-items">
          {navigationItems.map(item => (
            <button
              key={item.id}
              onClick={() => onPageChange(item.id)}
              className={`nav-item ${currentPage === item.id ? 'active' : ''}`}
            >
              <span className="nav-icon">{item.icon}</span>
              <span className="nav-label">{item.label}</span>
              {item.count > 0 && (
                <span className="nav-count">{item.count}</span>
              )}
            </button>
          ))}
        </nav>

        {/* User Section */}
        <div className="nav-user">
          {/* Quick Stats */}
          <div className="quick-stats">
            <div className="quick-stat">
              <span className="stat-icon">‚≠ê</span>
              <span className="stat-value">{quickStats.level || 1}</span>
            </div>
            <div className="quick-stat">
              <span className="stat-icon">üî•</span>
              <span className="stat-value">{quickStats.streak || 0}</span>
            </div>
          </div>

          {/* Notifications */}
          <div className="notification-container">
            <button
              className="notification-button"
              onClick={() => setNotificationMenuOpen(!notificationMenuOpen)}
            >
              üîî
              {unreadNotifications > 0 && (
                <span className="notification-badge">{unreadNotifications}</span>
              )}
            </button>

            {notificationMenuOpen && (
              <div className="notification-menu">
                <div className="notification-header">
                  <h4>Notifications</h4>
                  <button onClick={() => setNotificationMenuOpen(false)}>‚úï</button>
                </div>
                <div className="notification-list">
                  {notifications.length > 0 ? (
                    notifications.slice(0, 5).map(notification => (
                      <div key={notification.id} className={`notification-item ${notification.read ? 'read' : 'unread'}`}>
                        <span className="notification-icon">{notification.icon}</span>
                        <div className="notification-content">
                          <p className="notification-title">{notification.title}</p>
                          <p className="notification-time">{notification.time}</p>
                        </div>
                      </div>
                    ))
                  ) : (
                    <div className="notification-empty">No notifications</div>
                  )}
                </div>
                <button className="view-all-notifications" onClick={onNotifications}>
                  View All
                </button>
              </div>
            )}
          </div>

          {/* User Profile */}
          <div className="profile-container">
            <button
              className="profile-button"
              onClick={() => setProfileMenuOpen(!profileMenuOpen)}
            >
              <img
                src={user?.avatar || 'https://library-server-m6gr.onrender.com/default-avatar.png'}
                alt={user?.name || 'User'}
                className="profile-avatar"
              />
              <span className="profile-name">{user?.name || 'User'}</span>
            </button>

            {profileMenuOpen && (
              <div className="profile-menu">
                <div className="profile-header">
                  <img src={user?.avatar || 'https://library-server-m6gr.onrender.com/default-avatar.png'} alt={user?.name} />
                  <div>
                    <h4>{user?.name}</h4>
                    <p>{user?.email}</p>
                  </div>
                </div>
                <div className="profile-stats">
                  <div className="profile-stat">
                    <span>Level {quickStats.level || 1}</span>
                    <span>{quickStats.totalPoints || 0} points</span>
                  </div>
                </div>
                <div className="profile-actions">
                  <button onClick={onProfile} className="profile-action">
                    <span>üë§</span>
                    <span>Profile</span>
                  </button>
                  <button onClick={onSettings} className="profile-action">
                    <span>‚öôÔ∏è</span>
                    <span>Settings</span>
                  </button>
                  <div className="profile-divider"></div>
                  <button className="profile-action logout">
                    <span>üö™</span>
                    <span>Sign Out</span>
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </header>
  );
};

// Main Enhanced Book Library App Component
const EnhancedBookLibraryApp = ({ 
  books = [],
  onBookUpdate,
  user,
  analytics = {},
  className = ''
}) => {
  // Core State
  const [currentPage, setCurrentPage] = useState('library');
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedGenres, setSelectedGenres] = useState([]);
  const [sortBy, setSortBy] = useState('title');
  const [viewMode, setViewMode] = useState('grid');
  const [settingsOpen, setSettingsOpen] = useState(false);

  // Batch Operations State
  const [batchMode, setBatchMode] = useState(false);
  const [selectedBooks, setSelectedBooks] = useState([]);
  const [batchUpdating, setBatchUpdating] = useState(false);

  // Loading and Error State
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Hooks
  const { showSnackbar } = useSnackbar();
  const { user: authUser } = useAuth();

  // Use provided user or auth user
  const currentUser = user || authUser;

  // Get unique genres from books
  const availableGenres = useMemo(() => {
    const genres = books
      .map(book => book.genre)
      .filter(Boolean)
      .filter((genre, index, array) => array.indexOf(genre) === index);
    return genres.sort();
  }, [books]);

  // Filter and sort books
  const filteredBooks = useMemo(() => {
    return books.filter(book => {
      const matchesSearch = !searchQuery || 
        book.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
        book.author.toLowerCase().includes(searchQuery.toLowerCase()) ||
        (book.genre && book.genre.toLowerCase().includes(searchQuery.toLowerCase()));
      
      const matchesGenre = selectedGenres.length === 0 || 
        selectedGenres.includes(book.genre);
      
      return matchesSearch && matchesGenre;
    });
  }, [books, searchQuery, selectedGenres]);

  const sortedBooks = useMemo(() => {
    const sorted = [...filteredBooks];
    sorted.sort((a, b) => {
      switch (sortBy) {
        case 'title':
          return a.title.localeCompare(b.title);
        case 'title-desc':
          return b.title.localeCompare(a.title);
        case 'author':
          return a.author.localeCompare(b.author);
        case 'author-desc':
          return b.author.localeCompare(a.author);
        case 'year':
          return (b.year || 0) - (a.year || 0);
        case 'year-desc':
          return (a.year || 0) - (b.year || 0);
        case 'genre':
          return (a.genre || '').localeCompare(b.genre || '');
        case 'dateAdded':
          return new Date(b.dateAdded || 0) - new Date(a.dateAdded || 0);
        case 'dateAdded-desc':
          return new Date(a.dateAdded || 0) - new Date(b.dateAdded || 0);
        case 'progress':
          return (b.progress || 0) - (a.progress || 0);
        case 'rating':
          return (b.rating || 0) - (a.rating || 0);
        default:
          return 0;
      }
    });
    return sorted;
  }, [filteredBooks, sortBy]);

  const readingBooks = useMemo(() => {
    return books.filter(book => book.isReading);
  }, [books]);

  const collectionsData = useMemo(() => {
    // Group books by collections
    const collections = books.reduce((acc, book) => {
      if (book.collections) {
        book.collections.forEach(collection => {
          if (!acc[collection]) acc[collection] = [];
          acc[collection].push(book);
        });
      }
      return acc;
    }, {});
    return collections;
  }, [books]);

  // Books needing covers
  const booksNeedingCovers = useMemo(() => {
    return books.filter(book => !book.cover && !book.cover_url && !book.coverImage).length;
  }, [books]);

  // Quick stats for navigation
  const quickStats = useMemo(() => ({
    totalBooks: books.length,
    currentlyReading: readingBooks.length,
    collections: Object.keys(collectionsData).length,
    notes: books.reduce((sum, book) => sum + (book.notes?.length || 0), 0),
    level: analytics.level || 1,
    streak: analytics.currentStreak || 0,
    totalPoints: analytics.totalPoints || 0
  }), [books, readingBooks, collectionsData, analytics]);

  // Event Handlers
  const handleBookRead = useCallback(async (book) => {
    console.log('üìñ Opening book:', book.title);
    setLoading(true);
    try {
      await onBookUpdate?.('read', book);
      showSnackbar({ message: `Opening "${book.title}"`, variant: 'info' });
    } catch (error) {
      console.error('Error opening book:', error);
      showSnackbar({ message: 'Failed to open book', variant: 'error' });
    } finally {
      setLoading(false);
    }
  }, [onBookUpdate, showSnackbar]);

  const handleBookEdit = useCallback((book) => {
    console.log('‚úèÔ∏è Editing book:', book.title);
    onBookUpdate?.('edit', book);
  }, [onBookUpdate]);

  const handleBookDelete = useCallback(async (book) => {
    console.log('üóëÔ∏è Deleting book:', book.title);
    try {
      await onBookUpdate?.('delete', book);
      showSnackbar({ message: `"${book.title}" deleted`, variant: 'success' });
    } catch (error) {
      console.error('Error deleting book:', error);
      showSnackbar({ message: 'Failed to delete book', variant: 'error' });
    }
  }, [onBookUpdate, showSnackbar]);

  const handleBookShare = useCallback(async (book) => {
    console.log('üì§ Sharing book:', book.title);
    try {
      await onBookUpdate?.('share', book);
      showSnackbar({ message: `"${book.title}" shared`, variant: 'success' });
    } catch (error) {
      console.error('Error sharing book:', error);
      showSnackbar({ message: 'Failed to share book', variant: 'error' });
    }
  }, [onBookUpdate, showSnackbar]);

  const handleAddToCollection = useCallback((book) => {
    console.log('üìÅ Adding to collection:', book.title);
    onBookUpdate?.('addToCollection', book);
  }, [onBookUpdate]);

  const handleToggleReading = useCallback(async (book) => {
    console.log('üìñ Toggling reading status:', book.title);
    try {
      await onBookUpdate?.('toggleReading', book);
      const action = book.isReading ? 'stopped reading' : 'started reading';
      showSnackbar({ message: `You ${action} "${book.title}"`, variant: 'info' });
    } catch (error) {
      console.error('Error toggling reading status:', error);
      showSnackbar({ message: 'Failed to update reading status', variant: 'error' });
    }
  }, [onBookUpdate, showSnackbar]);

  const handleFindCover = useCallback(async (book) => {
    console.log('üîç Finding cover for:', book.title);
    try {
      await onBookUpdate?.('findCover', book);
      showSnackbar({ message: `Found cover for "${book.title}"`, variant: 'success' });
    } catch (error) {
      console.error('Error finding cover:', error);
      showSnackbar({ message: 'Failed to find cover', variant: 'error' });
    }
  }, [onBookUpdate, showSnackbar]);

  const handleBatchUpdateCovers = useCallback(async () => {
    setBatchUpdating(true);
    console.log('üîÑ Starting batch cover update...');
    try {
      await onBookUpdate?.('batchUpdateCovers');
      showSnackbar({ 
        message: `Updated covers for ${booksNeedingCovers} books`, 
        variant: 'success' 
      });
    } catch (error) {
      console.error('Error updating covers:', error);
      showSnackbar({ message: 'Failed to update covers', variant: 'error' });
    } finally {
      setBatchUpdating(false);
    }
  }, [onBookUpdate, showSnackbar, booksNeedingCovers]);

  const handleToggleBatchMode = useCallback(() => {
    setBatchMode(!batchMode);
    setSelectedBooks([]);
  }, [batchMode]);

  const handleBookSelect = useCallback((book) => {
    setSelectedBooks(prev => {
      const isSelected = prev.some(b => b.id === book.id);
      if (isSelected) {
        return prev.filter(b => b.id !== book.id);
      } else {
        return [...prev, book];
      }
    });
  }, []);

  const handleBatchAction = useCallback(async (action) => {
    console.log(`üîÑ Batch ${action} for ${selectedBooks.length} books`);
    try {
      await onBookUpdate?.(action, selectedBooks);
      showSnackbar({ 
        message: `${action} applied to ${selectedBooks.length} books`, 
        variant: 'success' 
      });
      setSelectedBooks([]);
      setBatchMode(false);
    } catch (error) {
      console.error(`Error in batch ${action}:`, error);
      showSnackbar({ message: `Failed to ${action} books`, variant: 'error' });
    }
  }, [selectedBooks, onBookUpdate, showSnackbar]);

  // Page Navigation
  const handlePageChange = useCallback((page) => {
    setCurrentPage(page);
    // Clear batch mode when changing pages
    setBatchMode(false);
    setSelectedBooks([]);
  }, []);

  // Render page content based on current page
  const renderPageContent = () => {
    switch (currentPage) {
      case 'library':
        return (
          <div className="library-page">
            {/* Search and Filter Bar */}
            <SearchAndFilterBar
              searchQuery={searchQuery}
              onSearchChange={setSearchQuery}
              selectedGenres={selectedGenres}
              onGenreChange={setSelectedGenres}
              availableGenres={availableGenres}
              sortBy={sortBy}
              onSortChange={setSortBy}
              viewMode={viewMode}
              onViewModeChange={setViewMode}
              booksNeedingCovers={booksNeedingCovers}
              onBatchUpdateCovers={handleBatchUpdateCovers}
              batchUpdating={batchUpdating}
              batchMode={batchMode}
              onToggleBatchMode={handleToggleBatchMode}
              selectedBooks={selectedBooks}
              onBatchAction={handleBatchAction}
            />

            {/* Books Grid */}
            <div className={`books-grid ${viewMode}`}>
              {sortedBooks.length > 0 ? (
                sortedBooks.map(book => (
                  <EnhancedBookCard
                    key={book.id}
                    book={book}
                    viewMode={viewMode}
                    onRead={handleBookRead}
                    onEdit={handleBookEdit}
                    onDelete={handleBookDelete}
                    onShare={handleBookShare}
                    onAddToCollection={handleAddToCollection}
                    onToggleReading={handleToggleReading}
                    onFindCover={handleFindCover}
                    findingCover={batchUpdating && !book.cover}
                    selected={selectedBooks.some(b => b.id === book.id)}
                    onSelect={handleBookSelect}
                    batchMode={batchMode}
                    showProgress={true}
                  />
                ))
              ) : (
                <div className="empty-state">
                  <div className="empty-state-icon">üìö</div>
                  <h3>No books found</h3>
                  <p>
                    {searchQuery || selectedGenres.length > 0
                      ? 'Try adjusting your search or filters'
                      : 'Add some books to get started!'}
                  </p>
                  {!searchQuery && selectedGenres.length === 0 && (
                    <MD3Button 
                      variant="filled" 
                      onClick={() => onBookUpdate?.('add')}
                    >
                      Add Your First Book
                    </MD3Button>
                  )}
                </div>
              )}
            </div>
          </div>
        );

      case 'reading':
        return (
          <div className="reading-page">
            <div className="page-header">
              <h2>üìñ Currently Reading</h2>
              <p>Continue your reading journey</p>
            </div>
            
            <div className="reading-books">
              {readingBooks.length > 0 ? (
                readingBooks.map(book => (
                  <EnhancedBookCard
                    key={book.id}
                    book={book}
                    viewMode="grid"
                    onRead={handleBookRead}
                    onEdit={handleBookEdit}
                    onDelete={handleBookDelete}
                    onShare={handleBookShare}
                    onAddToCollection={handleAddToCollection}
                    onToggleReading={handleToggleReading}
                    onFindCover={handleFindCover}
                    showProgress={true}
                    className="reading-card"
                  />
                ))
              ) : (
                <div className="empty-state">
                  <div className="empty-state-icon">üìñ</div>
                  <h3>No books currently being read</h3>
                  <p>Start reading a book from your library to see it here!</p>
                  <MD3Button 
                    variant="filled" 
                    onClick={() => setCurrentPage('library')}
                  >
                    Browse Library
                  </MD3Button>
                </div>
              )}
            </div>
          </div>
        );

      case 'stats':
        return <EnhancedStatsPage books={books} analytics={analytics} />;

      case 'collections':
        return (
          <div className="collections-page">
            <div className="page-header">
              <h2>üìÅ Collections</h2>
              <p>Organize your books into collections</p>
            </div>
            
            <div className="collections-grid">
              {Object.keys(collectionsData).length > 0 ? (
                Object.entries(collectionsData).map(([collectionName, collectionBooks]) => (
                  <MD3Card key={collectionName} className="collection-card">
                    <h3>{collectionName}</h3>
                    <p>{collectionBooks.length} books</p>
                    <div className="collection-preview">
                      {collectionBooks.slice(0, 4).map(book => (
                        <img 
                          key={book.id}
                          src={book.cover || book.cover_url || '/default-cover.png'}
                          alt={book.title}
                          className="collection-book-cover"
                        />
                      ))}
                    </div>
                  </MD3Card>
                ))
              ) : (
                <div className="empty-state">
                  <div className="empty-state-icon">üìÅ</div>
                  <h3>No collections yet</h3>
                  <p>Create collections to organize your books by theme, genre, or any way you like!</p>
                  <MD3Button variant="filled">Create Collection</MD3Button>
                </div>
              )}
            </div>
          </div>
        );

      case 'notes':
        return (
          <div className="notes-page">
            <div className="page-header">
              <h2>üìù Notes & Highlights</h2>
              <p>Review your reading notes and highlights</p>
            </div>
            
            <div className="notes-content">
              <div className="empty-state">
                <div className="empty-state-icon">üìù</div>
                <h3>Notes feature coming soon</h3>
                <p>Create and manage reading notes and highlights</p>
              </div>
            </div>
          </div>
        );

      default:
        return (
          <div className="error-page">
            <h2>Page not found</h2>
            <p>The requested page could not be found.</p>
            <MD3Button variant="filled" onClick={() => setCurrentPage('library')}>
              Go to Library
            </MD3Button>
          </div>
        );
    }
  };

  return (
    <div className={`enhanced-book-library-app ${className}`}>
      {/* Enhanced Navigation Header */}
      <EnhancedNavigationHeader
        currentPage={currentPage}
        onPageChange={handlePageChange}
        user={currentUser}
        onSettings={() => setSettingsOpen(true)}
        onProfile={() => console.log('Profile clicked')}
        onNotifications={() => console.log('Notifications clicked')}
        notifications={[]}
        quickStats={quickStats}
      />

      {/* Main Content */}
      <main className="main-content">
        {/* Enhanced Welcome Dashboard - Only show on library page */}
        {currentPage === 'library' && (
          <EnhancedWelcomeComponent 
            books={books} 
            onNavigate={setCurrentPage}
            analytics={analytics}
          />
        )}

        {/* Loading State */}
        {loading && (
          <div className="loading-overlay">
            <CircularProgress />
            <p>Loading...</p>
          </div>
        )}

        {/* Error State */}
        {error && (
          <div className="error-banner">
            <span>‚ö†Ô∏è {error}</span>
            <button onClick={() => setError(null)}>‚úï</button>
          </div>
        )}

        {/* Page Content */}
        {renderPageContent()}
      </main>

      {/* Settings Dialog */}
      <SettingsDialog 
        open={settingsOpen} 
        onClose={() => setSettingsOpen(false)} 
      />

      {/* Floating Action Button */}
      <MD3BookLibraryFab
  onAddBook={() => onBookUpdate?.('add')}
  onQuickSearch={() => onBookUpdate?.('search')}
  onScanBook={() => onBookUpdate?.('scan')}
  className="library-fab"
      />
    </div>
  );
};

export default EnhancedBookLibraryApp;