// src/components/wrappers/LibraryPageWrapper.jsx - COMPLETE FULL VERSION
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../contexts/AuthContext';
import { useSnackbar } from '../Material3';
import EnhancedBookLibraryApp from '../EnhancedBookLibraryApp';
import API from '../../config/api';

const LibraryPageWrapper = () => {
  // State management
  const [books, setBooks] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [serverStatus, setServerStatus] = useState('checking');
  
  // Hooks
  const { user, token } = useAuth();
  const { showSnackbar } = useSnackbar();
  const navigate = useNavigate();

  // Initialize gamification context safely
const gamificationContext = useOptionalGamification();
  // Notification helper
  const showNotification = (message, variant = 'info') => {
    showSnackbar({ message, variant });
  };

  useEffect(() => {
    if (user && token) {
      checkServerAndFetchBooks();
    } else {
      setError('Please log in to view your library');
      setLoading(false);
    }
  }, [user, token]);

  // ‚úÖ COMPLETE: Check server connection and fetch books
  const checkServerAndFetchBooks = async () => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('üîç Checking server connection...');
      
      // Try a simple API call instead of health endpoint
      const testResponse = await API.get('/books', { timeout: 5000 });
      
      setServerStatus('online');
      console.log('‚úÖ Server is online');
      
      // If the test call succeeded, use its data
      setBooks(testResponse.data || []);
      
      // Initialize gamification data safely (non-blocking)
      if (gamificationContext) {
        try {
          console.log('üéØ Gamification context is available');
          // The gamification context will load its own data on mount
        } catch (gamificationError) {
          console.warn('‚ö†Ô∏è Gamification initialization failed (non-critical):', gamificationError.message);
          // Don't block the library page for gamification failures
        }
      }
      
      setLoading(false);
      
    } catch (error) {
      console.error('‚ùå Server connection failed:', error);
      
      // Only set offline status for network errors
      if (error.code === 'NETWORK_ERROR' || error.message.includes('Network Error')) {
        setServerStatus('offline');
        setError('Cannot connect to server. Please check your internet connection.');
      } else if (error.response?.status === 401) {
        userFriendlyError = 'Your session has expired. Please log in again.';
        setServerStatus('offline');
        navigate('/login');
        return;
      } else if (error.response?.status === 403) {
        userFriendlyError = 'You do not have permission to access this library.';
        setServerStatus('offline');
      } else if (error.response?.status === 500) {
        userFriendlyError = 'Server error. Please try again later.';
        setServerStatus('offline');
      } else if (error.message?.includes('Failed to fetch') || error.code === 'ERR_NETWORK') {
        userFriendlyError = 'Cannot connect to server. Please check your connection.';
        setServerStatus('offline');
      } else {
        setServerStatus('online'); // Server responded, but with an error
      }
      
      setError(userFriendlyError);
      setLoading(false);
    }
  };

  // ‚úÖ COMPLETE: Fetch books from API
  const fetchBooks = async () => {
    console.log('üìö LibraryPageWrapper: Starting to fetch books...');
    
    if (!user || !token) {
      console.log('‚ùå No authentication - user must log in first');
      setError('Please log in to view your library');
      setLoading(false);
      return;
    }
    
    try {
      console.log('üîç API Base URL:', API.defaults.baseURL);
      
      const response = await API.get('/books');
      console.log('üìö Books fetched successfully:', {
        count: response.data?.length || 0,
        books: response.data?.map(book => ({ 
          id: book.id, 
          title: book.title, 
          isReading: book.isReading 
        }))
      });
      
      setBooks(response.data || []);
      setError(null);
      setServerStatus('online');
      
    } catch (error) {
      console.error('‚ùå Failed to fetch books:', error);
      
      let userFriendlyError = 'Failed to load your library';
      
      if (error.response?.status === 401) {
        userFriendlyError = 'Your session has expired. Please log in again.';
      } else if (error.response?.status === 403) {
        userFriendlyError = 'You do not have permission to access this library.';
      } else if (error.response?.status === 500) {
        userFriendlyError = 'Server error. Please try again later.';
      } else if (error.message.includes('Failed to fetch')) {
        userFriendlyError = 'Cannot connect to server. Please check your connection.';
        setServerStatus('offline');
      }
      
      setError(userFriendlyError);
    } finally {
      setLoading(false);
    }
  };

  // ‚úÖ COMPLETE: Update reading status
  const updateReadingStatus = async (bookId, isReading) => {
    try {
      console.log(`üìñ ${isReading ? 'Starting' : 'Stopping'} reading for book:`, bookId);
      
      const requestData = {
        isReading: isReading,
        last_read: isReading ? new Date().toISOString() : undefined
      };
      
      const response = await API.patch(`/books/${bookId}/reading-status`, requestData);
      
      // Update local state immediately for better UX
      setBooks(prevBooks => 
        prevBooks.map(book => 
          book.id === bookId 
            ? { 
                ...book, 
                isReading: isReading,
                last_read: isReading ? new Date().toISOString() : book.last_read 
              } 
            : book
        )
      );
      
      const bookTitle = books.find(b => b.id === bookId)?.title || 'Unknown';
      console.log(`‚úÖ ${isReading ? 'Started' : 'Stopped'} reading: ${bookTitle}`);
      
      // Show success notification
      showNotification(
        `${isReading ? 'Started' : 'Stopped'} reading "${bookTitle}"`,
        'success'
      );
      
      return { success: true };
    } catch (error) {
      console.error(`‚ùå Failed to ${isReading ? 'start' : 'stop'} reading:`, error);
      
      const bookTitle = books.find(b => b.id === bookId)?.title || 'book';
      const action = isReading ? 'start reading' : 'stop reading';
      
      showNotification(
        `Failed to ${action} "${bookTitle}". Please try again.`,
        'error'
      );
      
      return { success: false, error };
    }
  };

  // ‚úÖ COMPLETE: Handle all book update actions
  const handleBookUpdate = async (action, book) => {
    console.log('üé¨ Book action triggered:', action, book?.title);
    
    switch (action) {
      case 'read':
        // ‚úÖ FIXED: Navigate to reader with CORRECT parameter name 'id'
        console.log('üìñ Opening reader for:', book.title, 'ID:', book.id);
        if (!book || !book.id) {
          console.error('Cannot open book: Invalid book or book ID', book);
          showNotification('Cannot open book: Invalid book data', 'error');
          return;
        }
        // ‚úÖ CRITICAL FIX: Use 'id' parameter to match the route definition
        navigate(`/read/${book.id}`);
        break;
        
      // ‚úÖ FIXED: Handle both naming conventions for reading actions
      case 'startReading':
      case 'start-reading':
        console.log('‚ñ∂Ô∏è Starting to read:', book.title);
        const startResult = await updateReadingStatus(book.id, true);
        if (startResult.success) {
          // Track gamification action safely
          if (gamificationContext && gamificationContext.trackAction) {
            try {
              await gamificationContext.trackAction('start_reading', { bookId: book.id });
            } catch (error) {
              console.warn('‚ö†Ô∏è Gamification tracking failed (non-critical):', error.message);
            }
          }
        }
        break;
        
      case 'stopReading':
      case 'stop-reading':
        console.log('‚èπÔ∏è Stopping reading:', book.title);
        const stopResult = await updateReadingStatus(book.id, false);
        if (stopResult.success) {
          // Track gamification action safely
          if (gamificationContext && gamificationContext.trackAction) {
            try {
              await gamificationContext.trackAction('stop_reading', { bookId: book.id });
            } catch (error) {
              console.warn('‚ö†Ô∏è Gamification tracking failed (non-critical):', error.message);
            }
          }
        }
        break;

      // ‚úÖ COMPLETE: Cover update functionality
      case 'updateCover':
        console.log('üé® Updating cover for:', book.title);
        try {
          // Update the local state immediately for better UX
          setBooks(prevBooks => 
            prevBooks.map(existingBook => 
              existingBook.id === book.id 
                ? { ...existingBook, ...book }
                : existingBook
            )
          );
          
          // Send update to server
          await API.patch(`/books/${book.id}`, {
            cover_url: book.cover_url,
            cover_small_url: book.cover_small_url,
            cover_medium_url: book.cover_medium_url,
            cover_large_url: book.cover_large_url,
            api_source: book.api_source,
            enhanced_metadata: book.enhanced_metadata
          });
          
          showNotification(`Updated cover for "${book.title}"`, 'success');
        } catch (error) {
          console.error('Failed to update cover:', error);
          showNotification('Failed to update book cover', 'error');
        }
        break;

      case 'edit':
        console.log('‚úèÔ∏è Edit book:', book?.title);
        showNotification('Book editing feature coming soon!', 'info');
        break;
        
      case 'delete':
        if (book?.id && window.confirm(`Delete "${book.title}"?`)) {
          try {
            setLoading(true);
            await API.delete(`/books/${book.id}`);
            
            // Remove from local state
            setBooks(prevBooks => prevBooks.filter(b => b.id !== book.id));
            
            showNotification(`"${book.title}" deleted successfully`, 'success');
          } catch (err) {
            console.error('Delete failed:', err);
            showNotification('Failed to delete book', 'error');
          } finally {
            setLoading(false);
          }
        }
        break;
        
      case 'add':
      case 'upload':
        console.log('‚¨ÜÔ∏è Navigate to upload page');
        navigate('/upload');
        break;
        
      case 'import':
        showNotification('Bulk import feature coming soon!', 'info');
        break;
        
      case 'scan':
        showNotification('Barcode scanning feature coming soon!', 'info');
        break;
        
      case 'share':
        console.log('üì§ Sharing book:', book.title);
        if (navigator.share) {
          try {
            await navigator.share({
              title: book.title,
              text: `Check out "${book.title}" by ${book.author}`,
              url: window.location.href
            });
          } catch (error) {
            console.log('Share cancelled or failed:', error);
          }
        } else {
          // Fallback for browsers without Web Share API
          navigator.clipboard.writeText(`"${book.title}" by ${book.author}`);
          showNotification('Book details copied to clipboard', 'success');
        }
        break;
        
      case 'addToCollection':
        console.log('üìÅ Adding to collection:', book.title);
        showNotification('Collections feature coming soon!', 'info');
        break;
        
      case 'toggleReading':
        const newStatus = !book.isReading;
        await updateReadingStatus(book.id, newStatus);
        break;
        
      case 'findCover':
        console.log('üîç Finding cover for:', book.title);
        showNotification('Cover search feature coming soon!', 'info');
        break;
        
      case 'refresh':
        console.log('üîÑ Refreshing books list');
        await checkServerAndFetchBooks();
        break;
        
      default:
        console.log('Unknown action:', action);
    }
  };

  // ‚úÖ COMPLETE: Refresh books functionality
  const refreshBooks = async () => {
    console.log('üîÑ Refreshing books...');
    setLoading(true);
    await fetchBooks();
  };

  // ‚úÖ COMPLETE: Batch operations support
  const handleBatchOperation = async (operation, selectedBookIds) => {
    console.log(`üîÑ Performing batch operation: ${operation} on ${selectedBookIds.length} books`);
    
    try {
      switch (operation) {
        case 'delete':
          const confirmed = window.confirm(`Are you sure you want to delete ${selectedBookIds.length} books? This action cannot be undone.`);
          if (!confirmed) return;
          
          await Promise.all(
            selectedBookIds.map(bookId => API.delete(`/books/${bookId}`))
          );
          
          setBooks(prevBooks => 
            prevBooks.filter(book => !selectedBookIds.includes(book.id))
          );
          
          showNotification(`Deleted ${selectedBookIds.length} books`, 'success');
          break;
          
        case 'markCompleted':
          await Promise.all(
            selectedBookIds.map(bookId => 
              API.patch(`/books/${bookId}`, { 
                completed: true, 
                completed_date: new Date().toISOString() 
              })
            )
          );
          
          setBooks(prevBooks => 
            prevBooks.map(book => 
              selectedBookIds.includes(book.id) 
                ? { ...book, completed: true, completed_date: new Date().toISOString() }
                : book
            )
          );
          
          showNotification(`Marked ${selectedBookIds.length} books as completed`, 'success');
          break;
          
        case 'addToCollection':
          showNotification('Batch collection management coming soon!', 'info');
          break;
          
        case 'updateCovers':
          showNotification('Batch cover update starting...', 'info');
          
          let successCount = 0;
          for (const bookId of selectedBookIds) {
            try {
              const book = books.find(b => b.id === bookId);
              if (book) {
                // Simulate cover finding - replace with actual cover API call
                await new Promise(resolve => setTimeout(resolve, 500));
                successCount++;
              }
            } catch (error) {
              console.error(`Failed to update cover for book ${bookId}:`, error);
            }
          }
          
          showNotification(`Updated ${successCount} of ${selectedBookIds.length} covers`, 'success');
          break;
          
        default:
          console.log('Unknown batch operation:', operation);
      }
    } catch (error) {
      console.error('Batch operation failed:', error);
      showNotification(`Batch operation failed: ${error.message}`, 'error');
    }
  };

  // ‚úÖ COMPLETE: Loading state component
  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-surface">
        <div className="text-center space-y-4">
          <div className="w-12 h-12 border-4 border-primary/20 border-t-primary rounded-full animate-spin mx-auto"></div>
          <p className="text-on-surface-variant">
            {serverStatus === 'checking' ? 'Checking server connection...' : 'Fetching your books...'}
          </p>
        </div>
      </div>
    );
  }

  // ‚úÖ COMPLETE: Error state component
  if (error) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-surface">
        <div className="text-center space-y-4 max-w-md mx-auto p-8">
          <div className="text-6xl text-error">
            {serverStatus === 'offline' ? 'üåê' : '‚ùå'}
          </div>
          <h3 className="text-xl font-semibold text-on-surface">
            {serverStatus === 'offline' ? 'Connection Problem' : 'Library Error'}
          </h3>
          <p className="text-on-surface-variant">{error}</p>
          
          <div className="flex gap-2 justify-center">
            <button 
              onClick={checkServerAndFetchBooks}
              className="bg-primary text-on-primary px-4 py-2 rounded hover:bg-primary/90 transition-colors"
            >
              Try Again
            </button>
            {serverStatus === 'offline' && (
              <button 
                onClick={() => window.location.reload()}
                className="bg-secondary text-on-secondary px-4 py-2 rounded hover:bg-secondary/90 transition-colors"
              >
                Reload Page
              </button>
            )}
          </div>
          
          {process.env.NODE_ENV === 'development' && (
            <div className="text-xs text-on-surface-variant bg-surface-variant p-2 rounded mt-4">
              <strong>Debug Info:</strong><br />
              Server Status: {serverStatus}<br />
              User: {user?.email || 'Not logged in'}<br />
              Token: {token ? 'Present' : 'Missing'}
            </div>
          )}
        </div>
      </div>
    );
  }

  // ‚úÖ COMPLETE: Success state - render the main library component
  console.log('üìö Rendering library with', books.length, 'books');
  
  return (
    <EnhancedBookLibraryApp
      books={books}
      onBookUpdate={handleBookUpdate}
      onBatchOperation={handleBatchOperation}
      onRefresh={refreshBooks}
      user={user}
      analytics={{
        totalBooks: books.length,
        booksReading: books.filter(b => b.isReading).length,
        booksCompleted: books.filter(b => b.completed).length,
        // Add more analytics as needed
      }}
      serverStatus={serverStatus}
      className="library-page-wrapper"
    />
  );
};

export default LibraryPageWrapper;